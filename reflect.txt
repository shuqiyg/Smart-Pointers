After finishing workshop 8, I have a better understanding of how smart pointers work and their advantages over raw pointer by using them to move Product objects into a vector inside a List object. Also I’ve designed an algorithm of quadratic complexity performance. 

In both List<Product> mergeRaw and List<Product> mergeSmart, I implement a nested for loop to search for a matching code from descriptions and prices. Since for every outer loop, we iterate the inner loop N times, so the worst case scenario will be N^2, which is a quadratic complexity.

One of the advantages of smart pointers is that they ensure due to RAII so the object will be deleted. If we use a raw pointer, like the one in mergeRaw, we have to delete for every possible exit point(delete matched), and there’s still a possibility of memory leak. In List<Product> mergeRaw, we have to delete matched in a try ..catch.. block otherwise a memory lost is guaranteeed Smart pointer calls its object’s or resource’s destructor when it itself is destroyed, so we don’t have to worry about deallocating the resource to free memory in our program.

When using smart pointers, we have be aware of that the host pointer detaches itself from the object or resource and reattaches the object or resource to the new pointer when transferring  the ownership, that means the move process does not duplicate or destroy the object or resource, a unique smart pointer cannot copy construct or copy assignment. For example, in Utitlies Module, we implement priceList += std::move(prod_ptr) instead of priceList += matched.
